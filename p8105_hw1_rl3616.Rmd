---
title: "p8105_hw1_rl3616"
author: "Ruipeng Li"
date: "`r format(Sys.Date())`"
output: github_document
---
```{r setup, message=FALSE}
library(moderndive)               #Attach the moderndive package
library(ggplot2)                  #Load in order to use ggplot
data("early_january_weather")     #Load a built-in dataset
```

# Problem 1
This dataset has "`r nrow(early_january_weather)`" rows and "`r ncol(early_january_weather)`" columns.

Variables include: "`r paste(names(early_january_weather), collapse = ", ")`".

Mean temperature (F): "`r round(mean(early_january_weather$temp, na.rm = TRUE), 2)`".

```{r}
p <- ggplot(early_january_weather, 
  aes(x = time_hour, y = temp, color = humid)) +      #initialize and setting up a ggplot object
  geom_point(alpha = 0.7) +                           #setting point transparency
  scale_x_datetime(
    date_breaks = "2 day",
    date_labels = "%d"
  ) +                                                 #customize x-axis scale for datetime data
  labs(
    title = "Temperature vs Time (colored by Humidity)",
    x = "Time in January (hourly data)",
    y = "Temperature (F)",
    color = "Humidity"
  ) +                                                 #set plot labels
  theme_minimal()                                     #apply a theme I love♡

p                                                     #show the garph

```

In the chart, each vertical line represents 0:00 a.m. of that day (e.g., the line labeled "02" corresponds to 0:00 a.m. on January 2). We can see that temperature peaks typically occur during the daytime between two midnights, while temperature troughs usually appear near 0:00 a.m. each day. 

Lighter blue dots indicate higher humidity.High nighttime humidity often leads to larger diurnal temperature swings (e.g., from January 6 to 11) and can cause sharp temperature drops (e.g., around January 15). Meanwhile, persistently high humidity tends to reduce diurnal temperature variation (e.g., from noon on January 11 to January 14).

```{r}
ggsave("temp_vs_time_humid.png", plot = p)
```
Here's the saving progress.

#Problem 2
```{r}
x <- rnorm(10)
x_logical <- x > 0
x_char <- letters[1:10]
x_factor <- factor(rep(c("low", "medium", "high"), length.out = 10))  #creating values

df <- data.frame(
    num = x,
    logi = x_logical,
    char = x_char,
    fac = x_factor
)                                                        #creating data frame containing my value
```
We create four columns with distinct types: a numeric vector ```num``` drawn from a standard Normal distribution, a logical vector ```logi``` indicating whether each numeric entry is greater than 0, a character vector ```char``` of length 10 (letters “a”–“j”), and a factor vector ```fac``` with three levels (“low”, “medium”, “high”). These are combined into a single data frame ```df``` and we can output it to check our data.
```{r}
df                                                       #using this to output all our data
```
Next step, we start with ```library(tidyverse)```in order to use pull.
```{r, message=FALSE}
library(tidyverse)                                       #Load tidyverse
df |> pull(num) |> mean()                            
df |> pull(logi) |> mean()
df |> pull(char) |> mean()
df |> pull(fac) |> mean()                                #Getting means
```

Here are our result, as we can see

```mean(num)``` and ```mean(logi)``` works.

```mean(char)``` and ```mean(fac)``` does not work.

Now we can try to applies ```as.numeric``` function to convert non-numeric variables into numeric.
```{r convert-to-numeric, warning=FALSE, results='hide'}
as.numeric(df$logi)
as.numeric(df$char)
as.numeric(df$fac)
```

Applying ```as.numeric(logi)``` converts ```True``` and ```False```into ```1/0```. 

Taking the mean again produces the same value as before — the proportion of ```TRUE``` values —
because logical variables are naturally coerced to numeric when used in arithmetic.

This explains why ```mean(logi`)``` works, while other non-numeric variables produce errors:
mean can only operate on numeric data.

Applying ```as.numeric(char)``` returns ```NA``` with a coercion warning,
which confirms that character data cannot be meaningfully converted to numbers
and therefore cannot have a mean.

Applying ```as.numeric(fac)``` successfully returns the internal integer codes of the factor levels. The mean can be computed on these codes, however the result is not substantively meaningful
unless the factor levels have a natural numeric ordering.
